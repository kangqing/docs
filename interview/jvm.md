# Java虚拟机

## JVM运行时数据区

1. 程序计数器，是jvm中内存占用最小的一块区域，线程私有，可以通过改变程序计数器的值来获取字节码解析的下一行的行号指示器。是唯一一个不会发生OutOfMemoryError的区域。
2. 虚拟机栈，也是线程私有的，它相当于是Java方法的内存模型，每一个Java方法执行的时候都会创建一个栈帧，用来存储本地变量表、操作数栈。方法出口等信息，每一个Java方法被调用到执行完毕的过程，就对应这个栈帧在虚拟机中从入栈到出栈的过程。

可能出现的异常：
①. StackOverFlowError: 当虚拟机栈的内存不能动态扩展的时候，如果请求的栈深度超过允许的最大栈深度，则会抛出此异常
②. OutOfMemoryError: 当虚拟机栈的内存可以动态扩展的时候，如果请求不到足够的内存，则会抛出此异常

3. 本地方法栈：和虚拟机栈一样也是线程私有的，唯一不同的是，虚拟机栈为Java方法服务，本地方法栈为本地方法（native方法）服务
4. Java堆：是虚拟机中管理的内存最大的一块区域，<font color="red">几乎所有对象实例</font>都是存在这里的。也是垃圾回收机制回收内存的区域。

## 元数据空间

元数据区的概念出现在Java8以后，在Java8以前成为方法区，元数据区使用的是直接内存，并不属于JVM运行时数据区的一部分，元数据区也是一块线程共享的内存区域，主要用来保存被虚拟机加载的类信息、常量、静态变量以及即时编译器编译后的代码等数据。一个元数据区的大小决定了Java虚拟机可以装载的类的多少。

由于元数据存储的信息不容易变动，因此它被安置在一块堆外内存，即直接内存，大小由-XX:MaxMetaspaceSize指定。

## 逃逸分析

上面说道，几乎所有对象实例都是分配到堆中，那么肯定有对象实例不是在堆中的，这就讲到了逃逸分析，随着 JIT 即时编译技术的发展与逃逸分析技术逐渐成熟，所有对象都分配到堆上变得不是那么绝对了。如果经过逃逸分析后发现，一个对象没有逃逸出方法的话，那么就有可能被优化成栈上分配。这样就无须在堆上分配内存了，也无须进行垃圾回收了；随着栈帧出栈方法结束，栈上分配的对象实例的生命周期也就结束了。

怎么界定逃逸分析？

答：很简单，方法内部 new 的对象实例，没有return,肯定没有发生逃逸，如果 return 之后被外部的变量引用，则发生逃逸。

## 类加载机制
加载过程
- 加载（获取来自任意来源的字节流并转换成运行时数据结构，生成Class对象）
- 验证（验证字节流信息符合当前虚拟机的要求，防止被篡改过的字节码危害JVM安全）
- 准备（为类变量分配内存并设置初始值）
- 解析（将常量池的符号引用替换为直接引用，符号引用是用一组符号来描述所引用的目标，直接引用是指向目标的指针）
- 初始化（执行类构造器、类变量赋值、静态语句块）

## 类加载器
- 启动类加载器：用C++语言实现，是虚拟机自身的一部分，它负责将 <JAVA_HOME>/lib路径下的核心类库，无法被Java程序直接引用
- 扩展类加载器：用Java语言实现，它负责加载<JAVA_HOME>/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用
- 系统类加载器：用Java语言实现，它负责加载系统类路径ClassPath指定路径下的类库，开发者可以直接使用

## 双亲委派
定义：如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。

优点：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次防止恶意覆盖Java核心API。

## 垃圾回收算法
java是有垃圾回收机制不用手动释放内存，垃圾回收机制主要算法有，标记-清除，标记-整理，复制算法，分代回收算法。
- 标记清除：是最基本的垃圾回收算法，先通过Roots GC 寻找没有引用的对象作为可以释放的内存空间，标记好之后可以删除，缺点是会产生大量不连续的内存碎片，
- 标记整理算法：优化了标记清除算法，标记好了之后，会把仍然生存的对象移动到一端，从临界点处清除可释放的空间，可以用在老年代的垃圾回收，
- 复制算法：把内存分成两个相等的区域，在其中一个区域分配内存，进行GC之后，把仍然存活的复制到另一个区域，释放当前区域的空间，两个区域调换角色；
- 分代回收：把Java堆分成年轻代和老年代，年轻代使用复制算法进行快速GC，老年代使用标记整理算法进行GC

Java堆具体可以分为年轻代和老年代，年轻代又可分为Eden区，s1和s2区，首先大内存的对象直接进入老年代，其他的对象实例进入Eden区，每经过一个年轻代的GC，Eden区中存活下来的复制到空的S2区，S1区中存活下来的加一岁如果没有超过阈值默认15岁，则进入S2区，超过阈值直接进入老年代，然后释放S1空间，S1和S2调换角色。

## 垃圾回收器

- 串行回收：在垃圾回收阶段，进行GC的时候，Stop the world 停止应用程序，由单线程GC进行垃圾回收。
- 并行回收：在垃圾回收阶段，进行GC的时候，Stop the world 停止应用程序，由多线程并行GC进行垃圾回收。
- CMS回收：在垃圾回收的某些阶段，可以不用 Stop the world，垃圾回收机制和应用程序可以同时执行。

- 串行垃圾回收器：采用串行的方法进行垃圾回收，其中 Stop the World 也就是代表进行垃圾回收的时候，会暂停应用程序，这显然是不能接受的
- 并行垃圾回收器CMS：采用4步骤，1-初始标记，2-并发标记，3-重新标记，4-并发删除，其中13两步还是会有 stw 问题。采用，并发清除的算法，会产生大量的碎片，通过参数可以调整解决，FGC之后会对老年代进行空间碎片整理，还是会发生 STW 现象，可以通过参数设置 n 次 FGC 之后进行一次碎片整理
- G1垃圾回收器：将内存分成 4 个区域，Eden 、Survivor、Old、H区，其中H区专门存放大型对象。这样划分不需要连续的内存空间，采用复制算法，不会产生大量的空间碎片。

1. Serial    年轻代  串行回收
2. Parallel  年轻代  并行回收
3. ParNew    年轻代  可以配合CMS并行回收，Parallel 不可以配合 CMS

4. SerialOld                   老年代
5. ParallelOld                 老年代
6. ConcurrentMarkSweep (CMS)   老年代  并发的，垃圾回收和应用程序可以同时运行，降低 STW 到200ms以内

7. G1  特定的设计，使java堆不再区分年轻代和老年代。
8. ZGC

JDK1.8 的默认的垃圾回收机制用的是年轻代 Parallel 和老年代 ParallelOld,所以现在讲的调优主要是针对这个垃圾回收器

## JVM 调优

定制JVM运行时参数来提高Java程序运行的速度。

JVM 参数有哪些？怎么查看一个java进程的参数？运行一段时间后卡顿，怎么优化？
### JVM 参数
1. 标准参数： java - 开头，所有的jvm都支持的参数，可以 java -help  查看
2. 非标准参数：java -X 开头，和特定的jvm版本对应的，可以 java -X 查看
3. 不稳定参数：java -XX 开头，和特定jvm版本对应。可以java -XX:+PrintCommandLineFlags 查看常用的，
java -XX:+PrintFlagsFinal 查看最终生效的不稳定参数  
java -XX:+PrintFlagsInitial 查看不稳定参数的默认值

### jinfo

jinfo 是 JDK 自带的命令，可以用来查看正在运行的 java 应用程序的扩展参数，包括Java System属性和JVM命令行参数；也可以动态的修改正在运行的 JVM 一些参数。当系统崩溃时，jinfo可以从core文件里面知道崩溃的Java应用程序的配置信息
jinfo <option> <pid>

no option 输出全部的参数和系统属性
-flag name 输出对应名称的参数
-flag [+|-]name 开启或者关闭对应名称的参数
-flag name=value 设定对应名称的参数
-flags 输出全部的参数
-sysprops 输出系统属性

### 排查线上cpu100%的问题
```
#首先使用 top命令查看出 CPU 100% 的进程 PID

#查看当前 PID 的进程中有哪些线程
# 查看当前 pid 中有哪些线程
top -Hp 进程pid

#然后找到 CPU 较高的线程的 PID 然后转换成 16 进制
#转换成 16 进制
# 把 pid 转换成 16 进制
printf '%x' 线程pid

#使用 jstack 生成 进程 pid 到一个文件 x.txt 中去
jstack 进程pid > x.txt

#打开文件，搜索 16 进制的值
# 打开生成的文件
vim x.txt

# 搜索生成的16进制数据
/16进制
# 往下看，找到业务代码哪行导致的

# 或者 jstack 进程pid | grep -A 10 16进制  查看相关的10行
```

### jConsole 和 Jvisualvm 工具
jconsole：用于对 JVM 中的内存、线程和类等进行监控；
jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。




