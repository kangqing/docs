# Redis

## 单线程的Redis为什么快

1. 纯内存操作
2. 单线程操作，避免了频繁的上下文切换
3. 合理高效的数据结构
4. 采用了非阻塞I/O多路复用机制（有一个文件描述符同时监听多个文件描述符是否有数据到来）

## Redis 的数据结构及使用场景

1. String字符串:字符串类型是 Redis 最基础的数据结构，首先键都是字符串类型，而且 其他几种数据结构都是在字符串类型基础上构建的，我们常使用的 set key value 命令就是字符串。常用在缓存、计数、共享Session、限速等。
2. Hash哈希:在Redis中，哈希类型是指键值本身又是一个键值对结构，哈希可以用来存放用户信息，比如实现购物车。
3. List列表（双向链表）:列表（list）类型是用来存储多个有序的字符串。可以做简单的消息队列的功能。
4. Set集合：集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一 样的是，集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。利用 Set 的交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。
5. Sorted Set有序集合（跳表实现）：Sorted Set 多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。可以做排行榜应用，取 TOP N 操作。

## ### Redis 的数据过期策略

Redis 中数据过期策略采用定期删除+惰性删除策略

* 定期删除策略：Redis 启用一个定时器定时监视所有的 key，判断key是否过期，过期的话就删除。这种策略可以保证过期的 key 最终都会被删除，但是也存在严重的缺点：每次都遍历内存中所有的数据，非常消耗 CPU 资源，并且当 key 已过期，但是定时器还处于未唤起状态，这段时间内 key 仍然可以用。

* 惰性删除策略：在获取 key 时，先判断 key 是否过期，如果过期则删除。这种方式存在一个缺点：如果这个 key 一直未被使用，那么它一直在内存中，其实它已经过期了，会浪费大量的空间。

* 这两种策略天然的互补，结合起来之后，定时删除策略就发生了一些改变，不在是每次扫描全部的 key 了，而是随机抽取一部分 key 进行检查，这样就降低了对 CPU 资源的损耗，惰性删除策略互补了未检查到的key，基本上满足了所有要求。但是有时候就是那么的巧，既没有被定时器抽取到，又没有被使用，这些数据又如何从内存中消失？没关系，还有内存淘汰机制，当内存不够用时，内存淘汰机制就会上场。淘汰策略分为：

  - 默认不进行数据淘汰，直接报错
  - Volatile-ttl 、volatile-random 、volatile-lru、 volatile-lfu
  - Allkeys-random、allkeys-lru、allkeys-lfu

推荐使用 LRU 策略，原理是把刚刚访问的数据放在链表的头部，长期不访问的主键后移到链表尾部，缓存满时优先删除尾部数据。

## LFU淘汰策略解决缓存污染的问题

主要用来解决缓存污染问题，缓存污染就是有太多数据几乎只会被访问一次，之后不被访问，这样的数据占用了大量的内存空间，使用 LFU 淘汰策略，相当于在 LRU 策略基础上，给每个数据加一个计数器，统计这个数据被访问次数，当淘汰数据时，首先根据数据的访问次数把访问频次最低的数据淘汰，如果访问次数相同，才会删除最久未使用的数据。

## 如何解决 Redis 缓存雪崩问题

缓存雪崩是指大量的缓存同时失效，或者redis 宕机。

1. 使用 Redis 高可用架构：使用 Redis 集群来保证 Redis 服务不会挂掉
2. 缓存时间不一致，给缓存的失效时间，加上一个随机值，避免集体失效
3. 限流降级策略：有一定的备案，比如个性推荐服务不可用了，换成热点数据推荐服务

## 缓存击穿

是指某个热点数据突然过期失效，然后针对这个热点数据的请求直接全部打到服务器。

解决办法就是设置热点数据没有过期时间。

## 如何解决 Redis 缓存穿透问题

缓存穿透指的是，数据既不在缓存中，也不再数据库中，一般来说时黑客的恶意攻击，专门访问不存在的数据。

1. 在接口做校验
2. 存null值（缓存击穿加锁,或设置不过期）
3. 布隆过滤器拦截： 将所有可能的查询key 先映射到布隆过滤器中，查询时先判断key是否存在布隆过滤器中，存在才继续向下执行，如果不存在，则直接返回。布隆过滤器将值进行多次哈希bit存储，布隆过滤器说某个元素在，可能会被误判。布隆过滤器说某个元素不在，那么一定不在。

## Redis的持久化机制

Redis为了保证效率，数据缓存在了内存中，但是会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，以保证数据的持久化。Redis的持久化策略有两种：

1. RDB：快照形式是直接把内存中的数据保存到一个dump的文件中，定时保存，保存策略。当Redis需要做持久化时，Redis会fork一个子进程，子进程将数据写到磁盘上一个临时RDB文件中。当子进程完成写临时文件后，将原来的RDB替换掉。
2. AOF：把所有的对Redis的服务器进行修改的命令都存到一个日志文件里，命令的集合。

使用AOF做持久化，每一个写命令都通过write函数追加到appendonly.aof中。aof的默认策略是每秒钟fsync一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据。
缺点是对于相同的数据集来说，AOF的文件体积通常要大于RDB文件的体积。根据所使用的fsync策略，AOF的速度可能会慢于RDB。
Redis默认是快照RDB的持久化方式。对于主从同步来说，主从刚刚连接的时候，进行全量同步（RDB）；全同步结束后，进行增量同步(AOF)。

## 如何保证数据库和缓存的双写一致性

我们常用的缓存可以分为两类：读写缓存和只读缓存

对于读写缓存，对数据增删改查的同时，需要选择写回策略将数据同步写回到数据库中。
同步直写策略：写缓存时，也在同一个事务中同步写数据库，能够保证一致性。
异步写回策略：对于非关键属性，可以等数据从缓存中淘汰时，再写回数据库，不能保证缓存的一致性。

对于只读缓存来说：
如果发生删改操作，既要更新数据库，也要删除缓存。
删除缓存或更新数据库失败导致的数据不一致问题，可以通过添加重试机制确保成功。
在删除缓存或者更新数据库期间，有其他线程并发读操作，导致其他线程读到旧值，方案是延迟双删。

```
// 伪代码
redis.delKey();
db.update();
Thread.sleep();//sleep的时间需要大于线程B读取旧值写入缓存的时间
redis.delKey();

```

延迟双删是先删除缓存，后更新数据库的情况下的解决办法。
如果先更新数据库，再删除缓存，则几乎很少有线程能读到旧值，对业务的情况影响最小。

