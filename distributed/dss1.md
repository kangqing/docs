# 缓存知识点

## 什么是缓存击穿？
某个热点数据缓存过期，大量请求在 redis 中请求不到结果，直接打到数据库造成缓存击穿。

解决思路：
1. 热点数据不设置过期时间。
2. 当访问 redis 之后得到的结果为空，在去数据库查询之前，可以把请求使用分布式锁锁定，只允许一个请求去数据库查询数据，查询到数据之后缓存到 redis, 剩下的等待分布式锁的线程可以通过一个双重检测机制，在查询数据库之前，再去 redis 中查询一次。

## 什么是缓存雪崩？
大量请求访问 redis 的时候，这个时候 redis 中的数据集体失效了，或者 redis 宕机了，这个时候，大量的请求只能去请求数据库，这就是缓存雪崩。

解决思路：
1. 保证 redis 的高可用
2. 在服务系统中进行本地缓存，例如 mybatis 的二级缓存
3. 进行限流降级操作
4. 对于大量缓存同时失效，可以采用不同的超时时间，避免缓存在同一时刻大量失效

例如，10000个请求， 3000个命中本地缓存返回结果，1000个去请求数据库，另外 6000 个进行限流降级操作，返回一个兜底数据。

## 什么是接口的幂等性？
例如一个支付接口，多次调用，对我们的系统产生的结果应该是一样的，即不会支付成功多次，这样就是保证了接口的幂等性，查询接口是天然幂等性接口。

### 如何保证接口幂等性？
基于 token + redis 的解决方案

    客户端向服务端获取 token,服务端缓存 token 到 redis 中，之后返回 token 到客户端，客户端携带 token 请求服务端，服务端 判断 redis 中是否存在 token ,存在则代表第一次访问接口，成功执行并删除 redis 中的 token,如果请求判断 redis 中不存在 token，则说明重复，返回客户端告知重复请求。

## redis 内存满了怎么办？
使用 `config get maxmemory` 获取到redis最大内存，默认是`0`也就是不受限制。redis 内存满了会执行`淘汰策略`，默认的淘汰策略是不淘汰，再写入直接报错。

### 淘汰策略介绍
1. noeviction: 不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息。 大多数写命令都会导致占用更多的内存(有极少数会例外, 如 DEL )。
2. allkeys-lru: 所有key通用; 优先删除最近最少使用(less recently used ,LRU) 的 key。
3. volatile-lru: 只限于设置了 expire 的部分; 优先删除最近最少使用(less recently used ,LRU) 的 key。
4. allkeys-random: 所有key通用; 随机删除一部分 key。
5. volatile-random: 只限于设置了 expire 的部分; 随机删除一部分 key。
6. volatile-ttl: 只限于设置了 expire 的部分; 优先删除剩余时间(time to live,TTL) 短的key。

maxmemory 用于指定 Redis 能使用的最大内存。既可以在 redis.conf 文件中设置, 也可以在运行过程中通过 CONFIG SET 命令动态修改。

### 策略选择：
1. 如果分为热数据与冷数据, 推荐使用 allkeys-lru 策略。 也就是, 其中一部分key经常被读写. 如果不确定具体的业务特征, 那么 allkeys-lru 是一个很好的选择。
2. 如果需要循环读写所有的key, 或者各个key的访问频率差不多, 可以使用 allkeys-random 策略, 即读写所有元素的概率差不多。
3. 假如要让 Redis 根据 TTL 来筛选需要删除的key, 请使用 volatile-ttl 策略。
4. volatile-lru 和 volatile-random 策略主要应用场景是: 既有缓存,又有持久key的实例中。 一般来说, 像这类场景, 应该使用两个单独的 Redis 实例。








