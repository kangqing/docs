# 线程池入门

线程池与数据库连接池非常相似，目的是提高服务器的响应能力。线程池可以设置一定的数量空闲线程，这些线程即使在没有任何任务时仍然不会释放。线程池也可以设置最大线程数，防止任务过多，压垮服务器。

## ThreadPoolExecutor
ThreadPoolExecutor 是应用最广泛的`底层线程池类`,它实现了`Executor`和`ExecutorService`接口。

## 创建线程池
**(1).当要执行的任务数小于核心线程数时，直接启动与任务数相同的工作线程**

下面创建一个线程池，核心线程数设置为 3，阻塞队列容量设置为 5，最大线程数设置为 8
```java
public class ThreadPoolExecutorTest {
    public static void main(String[] args) {
        BlockingQueue<Runnable> blockingQueue = new LinkedBlockingQueue<>(5);
        final ThreadPoolExecutor pool =
                new ThreadPoolExecutor(3, 8, 2000, TimeUnit.MILLISECONDS, blockingQueue);
        // 任务数设置为 2
        for (int i = 0; i < 2; i++) {
            pool.execute(() -> {
                System.out.println(Thread.currentThread().getId() + " is running...");
                try {
                    TimeUnit.MILLISECONDS.sleep(800);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }
    }
}
```
```
结果：
13 is running...
14 is running...
```

**(2).当任务数量大于核心线程数时，超过核心线程数的任务会加入阻塞队列，直到把阻塞队列装满**

调整任务数量为 5，观察运行结果如下，前面 3 个任务启动了 3 个核心线程并加入线程池，后面的 2 个任务加入阻塞队列，等前面 3 个线程执行完毕后，程序会从阻塞队列中取出后面两个任务，然后仍然使用核心线程执行。因此会发现执行最后两个任务的线程号与前面的相同。
```
结果：
13 is running...
14 is running...
15 is running...
15 is running...
14 is running...
```

**(3).当阻塞队列已满，且任务数不超过最大线程数时，启动非核心线程执行任务**

继续增加任务数为 10，运行后得出结果如下，核心线程数为 3，因此前面 3个任务会启动 3 个工作线程， 阻塞队列是 5 所以， 4-8 的这 5 个任务会进入阻塞队列，这时阻塞队列已满，9，10这两个任务会启动两个非核心线程，现在的工作线程数量是 5，小于线程池设置的最大线程数 8，这 5 个工作线程结束后，就会开始执行阻塞队列中的任务。
```
结果：
13 is running...
14 is running...
16 is running...
15 is running...
17 is running...
17 is running...
15 is running...
14 is running...
13 is running...
16 is running...
```

<font color='red'>注意：如果阻塞队列比较大，只会由当前工作线程数的线程分批执行阻塞队列中的任务，只有超过阻塞队列之后的任务才会创建新的工作线程，且不能超过最大线程数</font>

**(4).当阻塞队列已满，剩下的任务数正好达到最大线程数**

继续增加任务数为 13， 观察程序运行结果，先启动 3 个核心线程，然后 5 个任务进入阻塞队列，剩下的 5 个任务启动新的非核心线程。此时工作线程是 8 个，与线程池设置的最大线程数相等。执行完这 8 个任务后，这 8 和线程竞争阻塞队列中的 5 个任务执行
```
结果：
13 is running...
17 is running...
15 is running...
18 is running...
20 is running...
19 is running...
16 is running...
14 is running...
16 is running...
15 is running...
18 is running...
17 is running...
19 is running...
```

**(5).当阻塞队列已满，剩下的任务数加上核心线程数超过了最大线程数，则抛出异常 RejectedExecutionException(拒绝执行任务策略)**

继续增加任务数为 15，观察运行结果如下：启动 3 个核心线程，放进 5 个任务进入阻塞队列，再启动 5 个非核心线程达到最大工作线程数 8，还剩 2 个任务，这两个任务被拒绝执行，抛出异常，之后完成 8 个任务后，8 个工作线程竞争执行阻塞队列中的 5 个任务。

结果：
```java
Exception in thread "main" java.util.concurrent.RejectedExecutionException: Task com.yunqing.demoatest.threadpool.ThreadPoolExecutorTest$$Lambda$14/0x0000000800066840@5dfcfece rejected from java.util.concurrent.ThreadPoolExecutor@23ceabc1[Running, pool size = 8, active threads = 8, queued tasks = 5, completed tasks = 0]
	at java.base/java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2055)
	at java.base/java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:825)
	at java.base/java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1355)
	at com.yunqing.demoatest.threadpool.ThreadPoolExecutorTest.main(ThreadPoolExecutorTest.java:20)
20 is running...
13 is running...
15 is running...
17 is running...
14 is running...
19 is running...
16 is running...
18 is running...
20 is running...
15 is running...
13 is running...
17 is running...
18 is running...
```

**(6).由于设置非核心线程 2 秒后回收，所以观察线程池中工作线程数的变化**
```java
public class ThreadPoolExecutorTest {
    public static void main(String[] args) throws InterruptedException {
        BlockingQueue<Runnable> blockingQueue = new LinkedBlockingQueue<>(5);
        final ThreadPoolExecutor pool =
                new ThreadPoolExecutor(3, 8, 2000, TimeUnit.MILLISECONDS, blockingQueue);
        // 任务数设置为 13
        for (int i = 0; i < 13; i++) {
            pool.execute(() -> {
                System.out.println(Thread.currentThread().getId() + " is running...");
                try {
                    TimeUnit.MILLISECONDS.sleep(800);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }

        // 观察线程池中线程数量
        System.out.println("此时线程池中工作线程的数量 = " + pool.getPoolSize());

        TimeUnit.SECONDS.sleep(5);

        System.out.println("此时线程池中工作线程的数量 = " + pool.getPoolSize());
    }
}
```
```
结果：
20 is running...
16 is running...
17 is running...
19 is running...
18 is running...
13 is running...
14 is running...
15 is running...
此时线程池中工作线程的数量 = 8
18 is running...
17 is running...
19 is running...
13 is running...
16 is running...
此时线程池中工作线程的数量 = 3
```

## 关闭线程池
