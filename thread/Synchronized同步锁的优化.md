## 1. Synchronized同步锁的优化

在并发编程中，多个线程访问同一个资源的时候，就要考虑如何维护数据的原子性。 jdk1.5之前通过Synchronized关键字加同步锁是重量级锁，性能很差，但是在jdk1.6对它进行了优化，甚至在某些场景下，它的性能已经超越了 Lock 同步锁。下面就让我们一起看看它做了什么优化。

### 1.1 synchronized使用方式

1. 关键字加在方法上，锁定当前实例，实际上是对调用该方法的对象加锁，俗称“对象锁”。
2. 关键字加在代码块中，锁定括号中的对象；
3. 加在静态方法上，锁定的是当前类，实际上是对该类对象加锁，俗称“类锁”。

```
// 关键字在实例方法上，锁为当前实例
public synchronized void method1() {
    // code
}

// 关键字在代码块上，锁为括号里面的对象
public void method2() {
    Object o = new Object();
    synchronized (o) {
        // code
    }
}
// 类锁
public static synchronized void method3() {
    // code
}
```

### 1.2 synchronized实现锁的原理

JVM 中的同步是基于进入和退出`管程`（Monitor）对象实现的。每个对象实例都会有一个 Monitor，Monitor 可以和对象一起创建、销毁。

当多个线程同时访问一段同步代码时，多个线程会先被存放在 ContentionList 和 _EntryList 集合中，处于 block 状态的线程，都会被加入到该列表。接下来当线程获取到对象的 Monitor 时，Monitor 是依靠底层操作系统的 Mutex Lock 来实现互斥的，线程申请 Mutex 成功，则持有该 Mutex，其它线程将无法获取到该 Mutex，竞争失败的线程会再次进入 ContentionList 被挂起。

如果线程调用 wait() 方法，就会释放当前持有的 Mutex，并且该线程会进入 WaitSet 集合中，等待下一次被唤醒。如果当前线程顺利执行完方法，也将释放 Mutex。

![img](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202303/f78e6979c424cce677add97080811308.jpg)img

### 1.3 JDK1.6对它进行了什么优化？
#### 1.3.1 锁消除
当 synchronized 修饰的代码没有操作临界资源的情况，即使写了此关键字，也会被 JIT 即时编译消除掉；

#### 1.3.2 锁膨胀
```java
class Test {
    public void method() {
        for(int i = 0; i < 99999; i++) {
            synchronized(obj) {
                // 处理
            }
        }
    }
}
```
如上面的代码会频繁的加锁、解锁；JIT即时编译会优化成把 synchronized 向外膨胀，包住循环；
```java
class Test {
    public void method() {
        synchronized() {
            for(int i = 0; i < 99999; i++) {
                //处理
            }
        }
    }
}
```

#### 1.3.3 锁升级优化

为了提升性能，JDK1.6 引入了偏向锁、轻量级锁、重量级锁概念，来减少锁竞争带来的上下文切换，而正是新增的 Java 对象头实现了锁升级功能。

**Java对象头**

在 JDK1.6 JVM 中，对象实例在堆内存中被分为了三个部分：对象头、实例数据和对齐填充。其中 Java 对象头由 Mark Word、指向类的指针以及数组长度三部分组成。

**Mark Word**

Mark Word 记录了对象和锁有关的信息。Mark Word 在 64 位 JVM 中的长度是 64bit，我们可以一起看下 64 位 JVM 的存储结构是怎么样的。如下图所示：

![img](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202303/fd86f1b5cbac1f652bea58b039fbc8f8.jpg)img

锁升级功能主要依赖于 Mark Word 中的锁标志位和释放偏向锁标志位，Synchronized 同步锁就是从偏向锁开始的，随着竞争越来越激烈，偏向锁升级到轻量级锁，最终升级到重量级锁。 所以保证synchronized同步锁始终处于偏向锁或者短时间处于轻量级锁状态很重要，是synchronized性能高效的关键。

### 1.4 偏向锁

偏向锁主要是用来优化同一个线程多次申请同一个锁的竞争问题。

例如：下面这两种操作都会导致用户态与内核态的切换

1. 创建一个线程并在线程中执行循环监听的场景
2. 单线程操作一个线程安全的集合时，同一个线程每次都需要获取和释放锁；

偏向锁的作用就是：当一个线程再次访问这个同步方法时，该线程只需要去对象头中的 Mark Word 中判断是否有偏向锁指向当前线程的 ID，无需再次进入管程 Monitor 中去竞争了。

1. 当线程访问同步代码块时，会检查当前所的状态，第一个抢到锁的`线程锁的标志位`和无锁状态下的`线程标志位`都是`01`,仅仅是`是否偏向锁标志位`由 0 变成 1，并且记录抢到锁线程的 ID 标识当前线程进入了偏向锁状态；
2. 一旦出现其他线程竞争锁资源时，偏向锁就会撤销，只不过偏向锁的撤销要等待一个`安全点`；到达安全点之后，暂停偏向锁线程stop the world,检查此线程方法的执行状态，如果还在执行中，则升级为轻量级锁；反之，被其他线程抢占偏向锁；

结论：在高并发场景下，大量线程竞争同一个锁资源时，偏向锁就会被撤销，发生 stop the world 后，开启偏向锁会带来更大的性能开销，这时可以添加 JVM 参数关闭偏向锁来调优系统性能：

```
-XX:-UseBiasedLocking  # 关闭偏向锁（默认打开）
```

### 1.5 轻量级锁

1. 当另一个线程B竞争锁资源时，由于当前线程A是偏向锁，当发现 Mark Word 对象头中的线程 ID 不是自己，就会进行 CAS 操作获取锁，如果获取成功，则改写对象头中的线程 ID 为线程 B 的 ID，线程 B 进入偏向锁状态；如果 CAS 获取锁失败，则说明线程 A 还没有处理完方法，则线程 A 升级为轻量级锁；线程B 获取锁失败；

总结：轻量级锁适用于线程交替执行同步块的场景，绝大部分的锁在整个同步周期内都不存在长时间的锁竞争；

### 1.6 自旋锁与重量级锁

1. 当一个线程 B 执行同步方法，竞争锁资源时，判断当前线程 A 处于轻量级锁状态，B 进行 CAS 操作竞争锁失败，此时不会进入挂起状态，而是进入一种自旋状态；当线程 B 短时间自旋后竞争到了锁资源，则进入到轻量级锁状态执行；但是，如果自旋超过一定次数，仍不能获取到锁，则线程 A 的轻量级锁升级为重量级锁；线程 B 挂起，进入阻塞状态；

结论：在锁竞争不激烈且锁占用时间非常短的场景下，自旋锁可以提高系统性能，一旦锁竞争激烈或者锁占用时间过长，自旋锁会导致大量的线程处于 CAS 重试状态，占用 CPU 资源，反而增加系统开销，所以自旋锁和重量级锁的使用都要结合场景；

在高负载、高并发的场景下，设置 JVM 参数关闭自旋锁

```
-XX:-UseSpinning # 参数关闭自旋锁（默认打开）
```

### 1.7 逃逸分析

JIT编译器在动态编译同步代码块时候，判断同步块使用的锁对象是否只能够被一个线程访问，而没有被发布到其他线程，如果是，JIT编译器不会生成synchronized表示的机器码，消除了锁的使用。这就是逃逸分析技术；

锁升级过程图： ![img](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202303/84f4d5dd908788fec0940431b4b912f0.png)