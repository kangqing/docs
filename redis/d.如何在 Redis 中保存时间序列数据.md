# d.如何在 Redis 中保存时间序列数据？

有下面这样一个需求：记录用户在网站或者 App 上的点击行为数据，来分析用户行为。这里的数据一般包括用户 ID 、行为类型（例如浏览、登录、下单等）、行为发生的时间戳：

```bash
UserID, Type, Timestamp
```

假如需要周期性的统计近万台设备的实时状态，包括设备 ID、压力、温度、以及对应的时间戳：

```bash
DeviceID, Pressure, Temprature, Humidity, Timestamp
```

这些与发生时间相关的一组数据，就是时间序列数据。**这些数据的特点是没有严格的关系模型，记录的信息可以表示成键和值得关系**（例如，一个设备 ID 对应一条记录），所以，并不需要专门用关系型数据库来保存，而 Redis 的键值数据模型，正好可以满足这里的数据存取请求。Redis 基于自身数据结构以及扩展模块，提供了两种解决方案。

这里，就以物联网场景中统计设备状态指标值为例，聊聊不同解决方案的做法优缺点：

## 时间序列数据的读写特点

在实际应用中，时间序列数据通常是持续高并发写入的，例如，需要记录数万个设备的实时状态值，同时，时间序列数据的写入主要就是插入新数据，而不是更新一个已存在的数据，也就是说，一个时间序列数据被记录后通常就不会变了，因为它就代表了一个设备在某个时刻的状态值，（例如，一个设备在某个时刻的温度测量值，一旦记录下来，这个值本身就不会改变了）。

所以，**这种数据的写入特点很简单，就是插入数据快，这就要求我们选择的数据类型，在进行插入时，复杂度要低，尽量不要阻塞。**看到这，你可能第一时间想到的是 String 类型，但是，之前讲过， String 在记录小数据的时候，元数据的内存开销比较大，不太适合保存大量数据。

那我们在看看，时间序列的读操作有什么特点呢？

我们在查询时间序列的时候，既有对单条数据的查询，例如某个设备在某个时刻的运行状态信息，对应的就是这个设备的一条记录，也有对某个时间段范围内的数据的查询，例如每天早上 8 点到 10 点的所有设备的状态信息。

除此之外，还有一些更复杂的查询，比如对某个时间范围内的数据做聚合计算。这里的聚合计算，就是对符合条件 的所有数据进行计算，包括计算均值、最大/最小值、求和等。例如，我们要计算某个时间段内的设备压力的最大值，来判断是否有故障发生。

可以看到，时间序列的读操作，查询模式众多。所以看看 Redis 中针对时间序列数据要 写的快，Redis 的高性能写特性直接就可以满足了；而针对查询模式多，也就是要支持单点查询、范围查询和聚合计算， Redis 提供了保存时间序列数据的两种方案，分别是基于 Hash 和 Sorted Set的实现，以及基于 RedisTimeSeries 模块实现。

### 基于 Hash 和 Sorted Set 保存时间序列数据

Hash 和 Sorted Set 组合的方式有一个明显的好处是：他们是 Redis 内在的数据类型，代码成熟和性能稳定。所以，基于这两个数据类型保存时间序列数据，系统稳定性是可以预期的。

不过在学习前面的场景中，我们都只用一个数据类型存取数据，那么，**为什么保存时间序列的数据，要同时使用两种数据类型呢？这是第一个问题**

关于 Hash 类型，我们都知道，他的一个特点是，可以实现对单键的快速查询。这就满足了时间序列数据的单键查询需求，我们可以把时间戳作为 Hash 集合的 key,把记录的设备状态作为 Hash 集合的 value.

可以看下用 Hash 集合记录设备某一时刻温度值得示意图：

![img](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202103/f2e7bc4586be59aa5e7e78a5599830be.jpg)

当我们想要查询某个时间点或者多个时间点上的温度数据时，直接使用 HGET 命令或者 HMGET命令，就可以分别获得 Hash 集合中的一个 key 和多个 key 的value 值了。

举个例子：

```bash
# 获取设备某个时间戳的温度
HGET device:temperature 202008030905
"25.1"
# 获取设备多个时间戳的温度
HMGET device:temperature 202008030905 202008030907 202008030908
1) "25.1"
2) "25.9"
3) "24.9"
```

**但是 Hash 类型有一个短板：他并不支持对数据进行范围查询。**

虽然时间序列数据是按时间顺序插入 Hash 集合中的，但是 Hash 类型的底层结构时哈希表，并没有对数据进行有效索引。所以，如果对 Hash 类型进行范围查询的话，就需要扫描 Hash 集合中的所有数据，再把这些数据取回到客户端进行排序，然后，才能在客户端得到所查询范围内的数据，显然，查询效率很低。

为了能同时支持按时间戳范围的查询，可以用 Sorted Set 来保存时间序列数据，因为它能够根据元素的权重分数来排序，我们可以吧时间戳作为 Sorted Set 的权重分数，把时间点上记录的数据作为元素本身。

我还是以保存设备温度的时间序列数据为例，进行解释，下图是用 Sorted Set 集合保存的结果。

![img](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202103/9e1214dbd5b42c5b3452ea73efc8c67a.jpg)



使用 Sorted Set 保存数据后，我们就可以使用 `ZRANGEBYSCORE`命令，按照输入的最大时间戳和最小时间戳来查询这个时间范围内的温度值。如下图所示，我们来查询一下在 2020 年 8 月 3 日 9点 7 分 到 9 点 10 分的所有温度值：

```bash
# 查询设备在时间戳范围的温度值
ZRANGEBYSCORE device:temperature 202008030907 202008030910
1) "25.9"
2) "24.9"
3) "25.3"
4) "25.2"
```

现在我们知道了，同时使用 Hash 和 Sorted Set ,可以满足单个时间点和一个时间范围内的数据查询需求了，但是我们又会面临一个新的问题，**也就是我们要解答的第二个问题：如何保证写入 Hash 和 Sorted Set 是一个原子性的操作呢？**

所谓原子性操作，就是指我们执行多个写命令时（例如用HSET 命令和 ZADD 命令分别把数据写入 Hash 和 Sorted Set）,这些命令操作要么全部完成，要么都不完成。

只有保证了写操作的原子性，才能保证同一个时间序列数据，在 Hash 和 Sorted Set 中，要么保存了，要么都没保存。否则，就可能出现 Hash 集合中有时间序列数据，而 Sorted Set 中没有，那么，在进行范围查询时，就没有办法满足查询需求了。

那么Redis 是怎么保证原子性操作的呢？这就涉及到了 Redis 用来实现简单的事务的 multi 和 exec 命令。当多个命令及其参数本身无误时， multi 和 exec 命令可以保证执行这些命令时的原子性。

- MULTI 命令：表示一系列原子性操作的开始，收到这个命令后， Redis 就知道，接下来再次收到的命令需要放到一个管道中，后续一起执行，保证原子性。
- EXEC 命令：表示一系列原子性操作的结束。一旦 Redis  收到这个命令，就表示所有要保证原子性的命令操作都已经发送完毕，此时，Redis 开始执行刚才管道中的所有命令。

你可以看到下面这张示意图：

![img](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202103/c0e2fd5834113cef92f2f68e7462a262.jpg)

以保存设备状态信息的需求为例，我们执行下面的代码，把设备在 2020 年 8 月 3 号 9 时 5 分的温度，分别用 HSET 和 ZADD 命令写入 Hash 集合 和 Sorted Set 集合。

```bash

127.0.0.1:6379> MULTI
OK

127.0.0.1:6379> HSET device:temperature 202008030911 26.8
QUEUED

127.0.0.1:6379> ZADD device:temperature 202008030911 26.8
QUEUED

127.0.0.1:6379> EXEC
1) (integer) 1
2) (integer) 1
```

可以看到，Redis 收到客户端的 MULTI 命令。然后，客户端在执行 HSET 和 ZADD 命令后，Redis 返回结果为 QUEUED ，表示这两个命令暂时入队，先不执行，执行了 EXEC 命令之后， HSET 命令 和 ZADD 命令才开始执行，并返回成功结果。

接下来需要解决的第三个问题是**：如何对时间序列进行聚合计算？**

聚合计算一般被用来周期性的统计时间窗口内的数据汇总状态，在实时监控与预警等场景下会频繁执行。

因为 Sorted Set 只支持范围查询，无法直接进行聚合计算，所以，我们只能先把时间范围内的数据取回到客户端，然后在客户端自行完成聚合计算，这个方法虽然能完成聚合计算，但是会带来一定的潜在风险，也就是**大量数据在 Redis 实例和客户端间频繁传输，这回和其他操作命令竞争网络资源，导致其他操作变慢。**

在这个物联网项目中，就需要每 3 分钟统计一下各个设备的温度状态，一旦设备温度超过了设定的阈值，就要进行报警。这是一个典型的聚合计算的场景，我们可以看看这个过程中的数据体量。

假设我们需要每 3 分钟计算一次的所有设备指标的最大值，每个设备每 15 秒记录一个指标值，1 分钟就会记录 4 个值，3 分钟就会有 12 个值，我们要统计的设备指标数量有 33 个，所以，单个设备每 3 分在记录的指标数据有将近 400 个 33 * 12 = 396 而设备总数有 10000 台，这样一来，每 3 分钟就有将近 400 万条数据需要在客户端和 Redis 实例间进行传输。

为了避免客户端和 Redis 实例间频繁的大量传输数据，我们可以使用 RedisTimeSeries 来保存时间序列数据。

RedisTimeSeries 支持直接在 Redis 实例上进行聚合计算。还是以刚才每 3 分钟算一次最大值为例，在 Redis 实例上直接聚合计算，那么，对于单个设备的一个指标来说，每 3 分钟记录的 12 条数据可以聚合计算成一个值，单个设备每 3 分钟也就有 33 个聚合值需要传输， 1 万台设备也就 33 万条数据。数据量大约是在客户端做聚合计算的十分之一，很显然，可以减少大量数据传输对 Redis 实例网络 的性能影响。

所以，如果我们只需要进行单个时间点查询或是对某个时间范围查询的话，适合使用 Hash 和 Sorted Set 的组合，他们都是Redis 内在的数据结构，性能好，稳定性高，但是如果需要进行大量的聚合计算，同时网络带宽条件不是太好，Hash 和 Sorted Set 的组合就不太适合了，此时，使用 RedisTimeSeries 就更加合适一些。

### 基于 RedisTimeSeries 模块保存时间序列数据

RedisTimeSeries 是 Redis 的一个扩展模块，它专门面向时间序列数据提供了数据类型和访问接口，并且支持在 Redis 实例上直接对数据进行按时间范围的聚合计算。

因为 RedisTimeSeries 不属于 Redis 的内建功能模块，在使用时，我们需要先把它的源码单独编译成动态链接库 redistimeseries.so,再使用 loadmodule 命令加载，如下所示：

```bash
loadmodule redistimeseries.so
```

当用于时间序列数据存取时，RedisTimeSeries的操作主要有 5 个：

- 用 TS.CREATE命令创建时间序列数据集合；
- 用TS.ADD 命令插入数据；
- 用TS.GET 命令读取最新数据；
- 用 TS.MGET 命令按标签过滤查询数据集合
- 用 TS.RANGE 支持聚合计算的范围查询。

下面介绍如何使用这 5 个操作：

1. **用 TS.CREATE 命令创建一个时间序列数据集合**

   在 TS.CREATE 命令中，我们需要设置时间序列数据集合的 key 和数据的过期时间（以毫秒为单位）。此外，我们还可以为数据集合设置标签，来表示数据集合的属性。

    

   例如，我们执行下面的命令创建一个 key 为 device:temperature、数据有效期为 600秒的时间序列数据集合，也就是说，这个集合 600 秒后就会被自动删除，最后，我们给这个集合设置一个标签属性「device_id:1」,表明这个数据集合中记录的是属于设备 ID 号为 1的数据。

   ```bash 
   
   TS.CREATE device:temperature RETENTION 600000 LABELS device_id 1
   OK
   ```

2. **用 TS.ADD 命令插入数据，用 TS.GET获取最新数据**

   例如，执行下面操作，插入数据记录某个时间戳的温度，之后再读出来

   ```bash 
   
   TS.ADD device:temperature 1596416700 25.1
   1596416700
   
   TS.GET device:temperature 
   25.1
   ```

3. **用 TS.MGET 命令按标签过滤查询数据集合**

   在保持多个设备的时间序列数据时，我们通常会把不同设备的数据保持到不同集合中。此时，我们就可以使用 TS.MGET 命令，按照标签查询部分集合中的最新数据，在使用 TS.CREATE创建数据集合的时候，可以给集合设置标签属性，当查询时，就可以根据查询条件中添加对集合标签属性进行匹配，最后的查询结果只返回匹配上的集合中的最新数据。

   举个例子。假设一共 4 个集合为 4 个设备保存时间序列数据，设备 ID 号 1、2、3、4我们在创建数据集合时，把 device_id 设置为每个集合的标签。此时就可以使用下列的TS.MGET命令以及 FILTER 设置（这个配置项用来设置集合标签的过滤条件），查询 device_id 不等于 2 的所有其他设备的数据集合，并返回各自集合中的最新一条数据。

   ```bash
   
   TS.MGET FILTER device_id!=2 
   1) 1) "device:temperature:1"
      2) (empty list or set)
      3) 1) (integer) 1596417000
         2) "25.3"
   2) 1) "device:temperature:3"
      2) (empty list or set)
      3) 1) (integer) 1596417000
         2) "29.5"
   3) 1) "device:temperature:4"
      2) (empty list or set)
      3) 1) (integer) 1596417000
         2) "30.1"
   ```

4. **用TS.RANGE支持需要聚合计算 的范围查询**

   我们可以TS.RANGE 指定查询的数据的时间范围，同时用 AGGREGATION 参数指定要执行的聚合计算类型。

   RedisTimeSeries 支持的聚合计算类型很丰富，包括均值、最大最小值、求和等

   例如，在执行下面命令，可以按照每180秒的时间窗口，对 2020 年 8 月 3 日9时 5 分 和 9时 12 分这段时间内的数据进行均值计算。

   ```bash
   
   TS.RANGE device:temperature 1596416700 1596417120 AGGREGATION avg 180000
   1) 1) (integer) 1596416700
      2) "25.6"
   2) 1) (integer) 1596416880
      2) "25.8"
   3) 1) (integer) 1596417060
      2) "26.1"
   ```

   

RedisTimeSeries 是专门为时间序列数据访问设计的扩展模块，能支持在 Redis 实例上直接进行聚合计算，以及按标签属性过滤数据集合，当我们需要频繁进行聚合计算时，以及从大量集合中筛选出特定设备或用户的数据集合时， RedisTimeSeries 就可以发挥出优势了。