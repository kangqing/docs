# 8.切片集群，数据增多了该加内存还是加实例？

这里有一个问题：要用Redis保存5000万个键值对，每个键值对大概512B，为了能快速部署对外提供服务，应该选择多大内存的云主机呢？

计算一下，这些键值对所占的内存空间大约是25GB，（5000万 * 512B）所以，正常情况下，想到的第一个方案会是：选择一台32GB 的内存的云主机部署 Redis 实例。因为 32GB的内存除了能保存所有的 25GB 数据，还能留 7GB 的内存，可以保证系统的正常运行。同时我采用了 RDB 对数据做持久化，确保 Redis 实例故障后，还能从 RDB 恢复。

但是，在使用的过程中，我发现， Redis 有时候响应非常慢，后来，使用 INFO 命令查看 Redis 的 `latest_fork_usec`指标值（表示最后一次fork的耗时），结果显示这个指标值特别高，快到秒级别了。

这根 Redis 的持久化机制有关，在使用 RDB 进行持久化时， Redis 会 fork 子进程来完成，fork 操作的用时和 Redis 的数据量是正相关的， 而 fork 在执行时会阻塞主线程。数据量越大，fork 操作造成的主线程阻塞的时间越长。所以，在使用 RDB 对 25GB 的数据持久化时，数据量较大，后台运行的子进程在 Fork 创建时阻塞了主线程，于是导致了 Redis 变慢。

看来这第一个方案显然是不可行的，这个时候想到了切片集群，虽然组件切片集群比较麻烦，但是他可以保存大量数据，而且对 Redis 的主线程的阻塞影响较小。

切片集群：也叫分片集群，就是指启动多个 Redis 实例组成一个集群，然后按照一定的规则，把收到的数据划分成多份，每一份用一个实例保存，回到刚刚的场景，如果把 25GB 的数据平均分成 5 份，（当然也可以不平均分），使用 5 个实例保存，每个实例只需要保存 5GB 数据。

![img](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202102/793251ca784yyf6ac37fe46389094b26.jpg)

那么在切片集群中，实例为 5GB 的数据生成 RDB 时，数据量就小了很多， fork 子进程一般不会给主线程带来较长时间的阻塞。采用多个实例保存数据切片后，我们既能保存 25GB 数据，又能避免fork 子进程阻塞主线程而导致的响应突然变慢。

实际应用 Redis 中，随着用户或者业务规模的扩展，保存大量的数据的情况是无法避免的，而切片集群就是一个非常好的解决方案。

## 如何保存更多数据

在刚刚的案例中，为了保存大量数据，分别使用了大内存的云主机和切片集群两种方法，实际上，这两种方法对应了 Redis 应对数据增多的两种方案：纵向扩展和横向扩展。

- 纵向扩展：升级单个 Redis 实例的资源配置，包括增加内存、增加磁盘容量、使用更高配置的CPU
- 横向扩展：横向扩展相当于增加 Redis 实例个数。

![img](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202102/7a512fec7eba789c6d098b834929701a.jpg)

## 纵向扩展和横向扩展的优缺点

纵向扩展的优点是：实施起来直接、简单。不过这两个方案也面临两个潜在的问题。

第一个问题是：当使用 RDB 对数据进行持久化时候，如果数据量增加，需要的内存也会增加，主线程 fork 子进程时就可能会阻塞（比如刚刚例子中 的情况）不过，如果你不需要持久化保存Redis 数据，那么纵向扩展也是一个不错的选择。

第二个问题是：纵向扩展会受到硬件和成本的限制。

与纵向扩展相比，横向扩展是一个扩展性更好的方案。这是因为，要想保存更多的数据，采用这种方案，只用增加 Redis 的实例个数就行了，不用担心单个实例的硬件和成本限制。在面向百万、千万级别的用户规模时，横向扩展的 Redis 切片集群会是一个非常好的选择。

## 数据切片和实例的对应分布关系

在切片集群中，数据需要分布在不同的实例上，那么，数据和实例之间如何应对呢？这就和接下来要讲的`Redis Cluster`方案有关了，不过要先弄明白切片集群和Redis Cluster的联系与区别了。

实际上，切片集群是一种保存大量数据的通用机制，这个机制可以有不同的实现方案。在 Redis 3.0 之前，官方并没有针对切片集群提供具体的实现方案。从 3.0 开始，官方提供了一个名为 Redis Cluster 的方案，用于实现切片集群，Redis Cluster方案中就规定了数据和实例的对应规则。

具体说，Redis Cluster 方案采用哈希槽（Hash Slot）来处理数据和实例之间的映射关系。在Redis Cluster 方案中，一个切片集群共有 16384个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key,被映射到一个哈希槽中。

具体的映射过程分为两大步，首先根据键值对 key,按照CRC16 算法计算一个 16bit 的值；然后用这个 16bit 的值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应的哈希槽。

### 哈希槽如何映射到具体 Redis 实例上？

我们部署 Redis Cluster 切片集群方案的时候，可以使用 `cluster create`命令创建集群，此时， Redis 会自动把这些槽平均分布到集群实例上。

当然，我们也可以使用`cluster meet`命令手动建立实例间的连接，形成集群，在使用`cluster addslots`命令指定每个实例上的哈希槽个数。

举个例子，假设集群中不同 Redis 实例的内存大小不一致，如果把哈希槽平均分在各个实例上，在保存相同数据量的键值对，和内存大的实例相比，内存小的实例就会有更大的容量压力，遇到这种情况，就可以根据配置不同，手动分配哈希槽。

![img](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202102/7d070c8b19730b308bfaabbe82c2f1ab.jpg)

实例图中的切片集群一个三个实例，同时假设 5 个哈希槽，首先可以通过下面的命令手动分配哈希槽：实例1保存哈希槽0和1，实例2保存哈希槽2和3，实例3保存哈希槽4

```bash
redis-cli -h 172.16.19.3 -p 6379 cluster addslots 0,1
redis-cli -h 172.16.19.4 -p 6379 cluster addslots 2,3
redis-cli -h 172.16.19.5 -p 6379 cluster addslots 4
```

在集群运行的过程中，key1和key2计算完CRC16 的值后，对哈希槽总个数 5 取模，再根据各自的模数结果，就可以被映射到对应的实例1和实例3上了。

**在手动分配哈希槽时，需要把16384个哈希槽都分配完，否则 Redis 集群无法正常工作**

### 客户端如何定位数据在哪个实例？

在定位键值对数据时，它所处的哈希槽是可以通过计算得到的，这个计算可以在客户端发送请求时来执行，但是要进一步定位到实例，还需要知道哈希槽分布在哪个实例上。

一般来说，客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发送给客户端，但是在集群刚刚创建的时候，每个实例只知道自己被分配了哪些哈希槽，是不知道其他实例拥有的哈希槽信息的。

那么客户端为什么可以在访问任何一个实例时，都能获得所有的哈希槽信息呢？这是因为 Redis 实例会把自己的哈希槽信息发送给和它相连的其他实例，来完成哈希槽分配信息的扩散，当实例之间相互连接后，每个实例就都拥有了所有的哈希槽的映射关系了。

客户端收到哈希槽信息后，会把哈希槽信息缓存到本地，当客户端请求键值对时，会先计算所对应的哈希槽，然后就可以给相应的实例发送请求了。

但是在集群中，实例和哈希槽的对应关系并不是一成不变的，最常见的变化有两个：

- 在集群中，实例有新增或删除， Redis 需要重新分配哈希槽；
- 为了负载均衡， Redis 需要把哈希槽在所有实例上分布一遍。

此时实例之间还可以通过相互传递消息，获得最新的哈希槽分配信息，但是客户端无法主动感知这些变化，这就会导致，它缓存的分配信息和最新的分配信息不一致。

Redis Cluster方案提供了一种重定向机制，是指，客户端给一个实例发送读写操作时，这个实例并没有相应的数据，客户端要再给一个新的实例发送操作命令。

那客户的又是怎么知道重定向时的新的实例的访问地址呢？当客户端把一个键值对操作请求发送给一个实例时，如果这个实例上没有这个键值对映射的哈希槽，那么这个实例就会给客户端返回线面的 MOVED 命令响应结果，这个结果中就包含了新的实例的访问地址

```bash
GET hello:key
(error) MOVED 13320 172.16.19.5：6379
```

其中，MOVED 表示，客户端请求键值对所在的哈希槽为 13320 实际是在 172.16.19.5 这个实例上，这样一来，客户端就可以直接和 172.16.19.5连接，并发送请求操作了。

![img](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202102/350abedefcdbc39d6a8a8f1874eb0809.jpg)

看上图，说明一下MOVED命令的使用方法，由于负载均衡，Slot2中的数据已经从实例2迁移到了实例3中，但是客户端缓存仍然记录着Slot2在实例2的信息，所以会给实例2发送命令，实例2给客户端返回一条 MOVED命令，把Slot2的最新位置发送给客户端，客户端就会再次向实例3发送请求，同时还会更新本地缓存，把Slot2与实例对应关系更新过来。

需要注意的是，上图中，当客户端发送命令给实例2的时候，数据已经全部迁移到实例3上，如果Slot2中的数据较多，就可能会出现一种情况：客户端向实例2发送请求，但是此时，Slot2中只有一部分数据迁移到实例3，还有部分数据留在实例2，这种情况下，客户端会收到一条ASK 报错信息：

```bash
GET hello:key
(error) ASK 13320 172.16.19.5 6379
```

这个结果表示，哈希槽13320，正在迁移到172.16.19.5这个实例上，此时客户端需要先给这个实例发送一个 ASKING 命令，这个命令的意思是，让这个实例允许客户端执行接下来的发送命令。然后客户端再次向这个实例发送 GET 命令，以读取数据。

![img](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202102/e93ae7f4edf30724d58bf68yy714eeb0.jpg)

在上图中，Slot2正在由实例2向实例3迁移，key1和key2已经迁移过去，key3和key4还没有迁移，客户端向实例2请求key2后，就会收到实例2返回的 ASK 命令。

此时，客户端需要给实例3发送 ASKING 命令，然后在发送操作命令。

和MOVED 不同，ASK 命令并不会更新客户端的缓存的哈希槽分配信息，所以上图中，如果客户端再次请求 Slot2 中的数据，他还是会给实例2 发送请求，这也就是，ASK 命令的作用只是让客户端能给新实例发送一次请求，而不像 MOVED 命令那样，会更改本地缓存，让后续所有命令发往新的实例。