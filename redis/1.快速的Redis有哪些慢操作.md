# 1.快速的Redis有哪些慢操作

## redis为什么这么快？

一是因为他是内存数据库，所有操作都是在内存中完成，内存的访问速度本身就快，另一方面，主要是因为高效的数据结构。IO多路复用，也保证了多个客户端访问的高效性。

## redis的底层数据结构

一共有 6 种：简单动态字符串、双向链表、压缩列表、哈希表、跳表、整数数组

![图1](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202102/%E6%88%AA%E5%B1%8F2021-02-08%2020.25.47.png)

可以看到，只有String类型的底层数据结构是一种，简单动态字符串，其他4中类型都有两种底层数据结构，通常我们称这四种类型为`集合类型`,他们的特点就是一个键对应了一个集合的数据。



### 键和值是什么结构？

为了实现从键到值得快速访问，redis使用一个哈希表来保存`所有键值的指针`.

一个哈希表就是一个数组，数组中每个元素称为一个哈希桶，每个哈希桶中保存了键值对的指针。所以即使是集合，也是通过*value的指针找到的。

![图2](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202102/1cc8eaed5d1ca4e3cdbaa5a3d48dfb5f.jpg)

哈希表最大的优势就在于可以让我们使用`O(1)`的时间复杂度快速查找到键值对，这个查找过程主要依赖于哈希计算，和数据量多少没有关系，也就是说，不管哈希表里有10万或者100万个键值对，都只需要一次哈希计算就能找到哈希桶的位置。

**但是，这其中有个一个潜在的风险可能导致操作变慢：哈希表的冲突和 rehash 可能带来的操作阻塞问题**

### 为什么哈希表操作变慢了？

哈希冲突是指在进行哈希计算时，两个 key 的哈希值和哈希桶计算对应关系时候，正好落在同一个哈希桶中，Redis 解决哈希冲突的办法是通过链表，**同一个哈希桶中的多个元素用一个链表来保存，他们之间依次用指针连接**

![图3](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202102/8ac4cc6cf94968a502161f85d072e428.jpg)

这样依然存在一个问题，就是当哈希冲突链上的元素越来越多，因为链表只能通过指针逐一查找，所以就会导致这个冲突链上的查找消耗大量时间，效率降低，对于追求快速的 redis 这显然是不能接受的。

### rehash重新哈希操作

当链表过长的时候，redis 会对哈希表进行重新哈希操作，也就是增加现有的哈希桶数量，让逐渐增多的元素能够在更多的桶之间分散保存，减少哈希冲突的数量。

具体操作是这样的：

为了使 rehash 操作能加高效，实际上 redis 默认使用了两个全局哈希表：一开始插入数据的时候，默认使用哈希表1，此时的哈希表2并没有分配空间。随着数据逐渐增多，redis 开始执行重新哈希操作，这个过程主要分三步：

1. 给哈希表2分配更大的空间，例如是哈希表1大小的两倍
2. 把哈希表1中的数据重新映射并拷贝到哈希表2中
3. 释放哈希表1的空间，留用下一次 rehash

这个过程看似简单，但是第二部涉及大量的数据拷贝，如果一次性把哈希表1中的所有数据全部迁移完，会造成 redis 线程阻塞，无法执行其他请求。

### 渐进式 rehash

为了避免上面这个问题， Redis 采用了渐进式 rehash,简单来说就是第二步拷贝数据时，Redis 仍然能够正常处理请求，每处理一个请求时，从哈希表1中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 哈希冲突链拷贝到哈希表2中；等处理下一个请求时，再顺带拷贝哈希表1中下一个索引位置的 entries 

![图4](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202102/73fb212d0b0928d96a0d7d6ayy76da0c.jpg)



这样就能够把一次性大量的拷贝开销，分摊到了多次处理请求中，避免了耗时操作，保证了数据的快速访问。

对于String 类型来说，找到哈希桶就能直接进行操作了，所以哈希表的O(1)也就是他的时间复杂度了，但是对于集合来说，即使找到哈希桶，还要在集合中进行下一步操作，接下来，了解集合类型的操作效率又是怎样的。



## 集合数据操作效率

和String类型不一样，集合类型在找到哈希桶的位置之后，还需要了解集合的操作效率，首先集合的操作效率和底层的数据结构有关，例如哈希结构肯定比链表结构的访问效率高。

### 集合有哪些数据结构？

上面已经讲过，除了String 只使用到简单动态字符串结构，剩下的集合类型都是两种底层数据结构，这些数据结构有：**双向链表、整数数组、哈希表、压缩列表、跳表**

其中，哈希表刚刚讲过、数组和链表也很常见，基本特征都是顺序读写，通过数组的下标或者链表的指针逐个访问，时间复杂度O(N)，操作效率比较低。下面重点解释一下Redis重要的数据结构，**压缩列表和跳表**

### 压缩列表的数据结构

压缩列表实际上类似一个数组，和数组不同的是,压缩列表在头部有三个字段 `zlbytes、zltail和zllen`分别表示`列表长度、列表尾部偏移量、列表中entry的个数`，压缩列表的尾部还有个`zlend`表示列表结束。

![图5](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202102/9587e483f6ea82f560ff10484aaca4a0.jpg)

压缩列表如果查找第一个和最后一个元素，可以通过表头的三个字段直接定位，时间复杂度O(1) 但是查找其他元素时候，只能逐个查找，此时复杂度就是O(N)



### 跳表的数据结构

跳表就是在链表的基础上，添加了多级索引，通过索引位置的几个跳转，实现数据的快速定位：

![图6](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202102/1eca7135d38de2yy16681c2bbc4f3fb4.jpg)

假如我们在链表中找 33 这个数，需要从头遍历，查找 6 次，此时时间复杂度 O(N),效率很低。

为了提高查找效率，可以增加一级索引，每两个元素选一个作为索引，这些索引再通过指针指向原始链表，例如从前两个元素抽取 1 作为索引，从第三四个元素抽取 11 作为一级索引，此时我们只需查找 4 次就能找到元素 33.

如果还想再快，可以在一级索引的基础上，添加二级索引，二级索引指向一级索引，如图所示，这样一来，只需要 3 次查找就能找到 33

可以看到这个查找的过程就是在多级索引上跳来跳去，最后定位到元素，这就是跳表叫法的由来，跳表的时间复杂度是O(logN)

![图7](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202102/fb7e3612ddee8a0ea49b7c40673a0cf0.jpg)



### 不同操作的复杂度

1. 单元素操作，是指每一种集合类型对单个数据实现的增删改查操作。例如，hash类型的 HGET、HSET、HDEL,例如 Set 类型的SADD、SREM、SRANDMEMBER等。这些操作的复杂度由集合采用的数据结构决定，HGET等都是对哈希表进行操作，时间复杂度是O(1),而Set类型用哈希表作为底层数据结构时，SADD等操作也是O(1)的时间复杂度。

   这里有个地方需要注意，例如 Hash类型的HMGET和HMSET， Set类型的SADD支持对多个元素进行增删改查，当操作多个元素时候,例如N个元素，时间复杂度也就变成了 O(N)

2. 操作范围，是指集合类型中的遍历操作，可以返回集合中的所有数据，例如Hash类型中的 HGETALL 和 HMSET, 例如 Set 类型的 SMEMBMBERS 或者返回一个范围内的部分数据，比如 List 类型的 LRANGE 和 ZSet 类型的 ZRANGE 。这类操作的复杂度一般是O(N),比较耗时间，应该尽量避免。

   也可以使用自Redis2.8开始提供的 SCAN 系列操作（包括 HSCAN, SSCAN 和 ZSCAN）这类操作实现了渐进式遍历，每次返回有限量的数据，避免了一次性返回所有元素而导致 Redis 阻塞。

3. 统计操作，是指集合类型对集合中所有元素个数的记录， 例如 LLEN 和 SCARD 这类操作的复杂度只有 O(1) 这是因为当集合类型采用压缩列表、双向链表、整数数组这些数据结构时，这些结构中专门记录了元素的个数统计，因此可以高效的完成现骨干操作。

4. 例外情况，是指某些数据机构的特殊记录， 例如压缩列表和双向链表都会记录表头和表尾的偏移量。这样一来对于 List 类型的 LPOP、RPOP、LPUSH、RPUSH这四个操作来说，他们是在列表的头尾增删元素，时间复杂度也是 O(1),可以快速操作。

