# 4.内存快照：宕机后Redis如何实现快速恢复

AOF 方法进行故障恢复需要逐一把操作日志的命令都执行一遍，如果操作日志非常多，Redis 就会恢复的很缓慢，影响到正常使用。这当然不是理想的结果。那么有没有既可以保证可靠性，还能再宕机时实现快速恢复的其他方法呢？

## 内存快照

所谓内存快照，就是指内存中的数据在某一时刻的状态记录。

对于 Redis 来说，它实现类似照片记录效果的方式，就是把某一时刻的状态以文件的形式写到磁盘上，也就是快照。这样一来，即使宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。这个快照文件就成为 `RDB`文件，也就是 `Redis DateBase`的缩写。

和 AOF 相比， RDB记录的是某一时刻的数据，并不是操作，所以在做数据恢复时，我们可以直接把 RDB 文件读入内存，很快的完成恢复。听起来不错，但是内存快照也不是最优选项，为什么呢？

考虑两个关键问题：

- 对那些数据做快照？这关系到快照的执行效率问题；
- 做快照时，数据还能被增删改吗？这关系到Redis是否被阻塞，能否同时正常处理请求。

### 给哪些内存数据进行快照？

Redis 的数据都在内存中，为了提供所有数据的可靠性保证，他执行的是**全量快照**，也就是说，把内存中的所有数据都记录到磁盘中，这样做的好处是，一次性记录了所有数据，一个都不少。

当你给一个人拍照，只需协调一个人就够了，相同的给内存的全量数据做快照，把他们全部写入磁盘也会花费很多时间。而且，全量数据越多， RDB 文件越大，往磁盘写数据的时间开销就越大。

对于 Redis 而言，单线程模型决定了，要尽量避免所有会阻塞主线程的操作，针对任何操作，都应该考虑，他会阻塞主线程吗？ RDB文件的生成是否会阻塞主线程，这关系到是否会降低 Redis 的性能。

Redis 提供了两个命令来生成 RDB 文件，分别是 `save`  和 `bgsave`

- save： 在主线程中执行会导致阻塞；
- bgsave: 创建一个子线程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB文件的默认生成配置。

这个时候就可以通过 bgsave 命令来执行全量快照，这既提供了数据的可靠性保证，也避免了对Redis 的性能的影响。

### 快照时数据能修改吗？

和拍照类似，我们做快照的时候肯定是希望数据不要动，但是如果为了快照而暂停写操作，肯定是不能接受的。这个时候，Redis 会借助操作系统提供的写时复制技术`（copy-on write, COW）`在执行快照的同时，正常处理写操作。

简单来说， bgsave 子进程是由主线程 fork 而来的，可以共享主线程的所有内存数据。此时，如果主线程要修改一块数据（例如图中的键值对 C），那么这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。

![img](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202102/4dc5fb99a1c94f70957cce1ffef419cc.jpg)

这样既保证了快照的完整性，也允许主线程同时对数据进行修改，避免了对正常业务的影响。

Redis 会使用 bgsave 对当前内存中所有数据做快照，这个操作是子进程在后台完成的，这就允许主线程同时可以修改数据。

### 可以每秒做一次快照吗

不可以！

如下图所示，先在 T0 时刻作了一次快照，然后又在 T0 + t 时刻作了一次快照，在这期间，数据块 5 和 9 被修改了。如果在这 t 时间段内，机器宕机了，那么只能按照 T0 时刻的快照进行恢复。此时数据块 5 和 9 的修改值因为没有快照记录，就无法恢复了。

![img](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202102/711c873a61bafde79b25c110735289ab.jpg)



如果频繁的执行全量快照，会带来两方面的开销。

一方面：频繁将全部数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，造成恶性循环。

另一方面， bgsave 子进程需要 fork 主线程，虽然，子线程在创建后不会再阻塞主线程，但是 fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长，如果频繁 fork ，就会频繁阻塞主线程。

### 增量快照

增量快照是指，在做了一次全量快照之后，后续的快照只对修改的数据进行快照，这样就可以避免每次全量快照的开销。

在第一次全量快照之火， T1 和 T2 时刻如果再需要进行快照，只需将被修改的数据写入快照文件就行。但是，这么做的前提是，我们需要记住那些数据被修改了。你可不要小瞧这个记住的功能。他需要我们使用额外的元数据信息去记录哪些数据被修改了，这将会带来额外的空间开销问题。

![img](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202102/8a1d515269cd23595ee1813e8dff28a5.jpg)

如果有一万个被修改的键值对，就要有一万条额外的记录。而且，有时候，键值对非常小，比如只有 32 字节，而记录他被修改的元数据信息，可能就需要 8 字节，这样为了记住修改，引入额外的空间开销比较大，对于内存宝贵的 Redis 来说，有些得不偿失了。

虽然跟 AOF 相比，快照的恢复速度比较快，但是快照的频率不好把握，如果频率太低，两次快照之间一旦宕机，就可能丢失较多的数据。如果频率太高，又会产生额外的开销，那么，有什么方法能够即利用 RDB 的快速恢复，又能以较小的开销做到尽量少丢失数据呢？

### 混合使用 AOF 日志和内存快照

Redis 4.0 提出了一个混合使用 AOF 日志和内存快照的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。

这样一来，快照不用很频繁的执行，避免了频繁 fork 对主线程的影响。而且， AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况，也可以避免重写开销。

如下图所示， T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全景快照时，就可以清空 AOF 日志了。

![img](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202102/e4c5846616c19fe03dbf528437beb320.jpg)

这个方法既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势，建议在实践中用起来。

总结：

- 数据不能丢失时：内存快照和AOF 混用是一个很好的选择；
- 如果允许分钟级别的数据丢失， 可以只使用 RDB
- 如果只用 AOF ，优先使用 everysec 的配置选项，因为他在可靠性和性能之间取了一个平衡。

