# 3. AOF日志：宕机了Redis如何避免数据丢失

`Redis`的主要应用场景之一是用作缓存，一旦服务器宕机，内存中的缓存数据将全部丢失，那怎么解决呢？很容易想到的是，从后端数据库恢复这些数据，但是这种方式存在两个问题：一是，需要频繁访问数据库，会给数据库带来巨大的压力；二是，这些数据是从慢速的数据库中读取出来的，性能肯定比不上从`Redis`中读取，导致使用这些数据的应用程序响应变慢。所以，对于`Redis`来说，实现数据持久化，避免从后端数据库中进行恢复，是至关重要的。

目前，`Redis`的持久化主要有两大机制，即 `AOF(append only file)`日志和`RDB`快照。

## AOF日志是如何实现的

说到日志，我们比较熟悉的是数据库的写前日志，也就是在实际写数据之前，先把修改的数据记录到日志中，以便故障时进行恢复。不过，AOF日志正好相反，他是写后日志，`Redis`先执行命令，把数据写入内存，然后才记录日志：

![img](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202102/407f2686083afc37351cfd9107319a1f.jpg)

### AOF 为什么要先执行命令再记录日志呢？

传统的数据库日志，记录的是修改后的数据， 而 AOF 日志的内容是 `Redis`收到的每一条命令，这些命令是以文本的形式保存的。

这里以`Redis`收到 `set testkey testvalue`命令后记录的日志为例，看看 AOF 日志的内容，其中`*3`代表当前命令分为三个部分，每部分都是由`$+数字`开头，后面紧跟着具体的命令、键或值。这里，数字表示这部分中的命令、键值一共占多少字节。

![img](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202102/4d120bee623642e75fdf1c0700623a9f.jpg)



为了避免额外检查开销，`Redis`在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记录日志再执行命令的话，日志中就可能记载了错误的命令，`Redis`在使用日志恢复数据时，就可能会出错。

而采用写后日志的方式，就是先让系统执行命令，只有命令执行成功，才会被记录到日志中，这也是`Redis`使用写后日志的一大好处，可以避免出现记录错误命令的情况。

除此之外，AOF还有一个好处：他是在命令执行后才记录日志，所以不会阻塞当前的写操作。

### AOF 的两个潜在风险

首先，如果刚执行完一个命令，还没来得及记录日志就宕机了，那么这个命令和相应的数据就有丢失的风险，如果此时`Redis`用作缓存，还可以从后端数据库重新读入数据进行恢复，但是如果`Redis`用作数据库的话，此时，因为没有记录日志，所以就无法用日志进行恢复了。

其次， AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。这是因为，AOF日志也是在主线程中执行的，如果把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了。

仔细分析，这两个风险都是和 AOF 协会磁盘的时机相关的，这就意味着，如果我们能够控制一个写命令执行完后 AOF 日志写会的时机，这两个风险就解除了。

### 三种写回策略

其实，对于这个问题， AOF 提供了三个选择，也就是 AOF 配置项 `appendfsync`的三个可选值：

- `always`, 同步回写：每个写命令执行完，立马同步的将日志写回磁盘；
- `Everysec`, 每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘。
- `No`,操作系统控制的写回：每个写命令执行完，先把日志写到 AOF 文件缓冲区，由操作系统决定何时将缓冲区的内容写回磁盘。

针对避免主线程阻塞和减少数据丢失的问题，这三种写回策略都无法做到两全其美。分析下原因：

- 同步写回：可以做到基本不丢失数据，但是他在每一个写命令后都有一个慢速的落盘操作，不可变的影响主线程性能。
- 虽然操作系统控制的写回在写完缓冲区后，就可以继续执行后续命令。但是落盘的实际已经不在`Redis`手中了，只要 AOF 记录没有写回磁盘，一旦宕机对应的数据就会丢失；
- 每秒写回：采用一秒一次的频率，避免了同步写回的性能开销，虽然减少了对系统性能的影响，但是如果发生宕机，上一秒未落盘的命令操作依然会丢失，所以只能算是，在避免影响主线程性能和避免数据丢失两者间取了个折中。

![img](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202102/72f547f18dbac788c7d11yy167d7ebf8.jpg)

总结：想要获得高性能，选择 No 策略；如果想要得到高可靠性保证，就选择 Always 策略；如果允许数据有一点丢失，又希望性能别收太大影响，就选择 Everysec 策略。

但是，按照系统的性能需求选定了写回策略，并不是高枕无忧了，毕竟 AOF 是以文件的形式记录接收到的所有命令的，随着命令越来越多， AOF 文件会越来越大，这就意味着，我们一定要小心 AOF 文件过大带来的性能问题。

### AOF 文件过大造成的性能问题

一是：文件系统本身对于文件大小有限制，无法保存过大的文件；

二是：如果文件太大，之后再往里面追加命令记录的话，效率也会变低；

三是：如果发生宕机， AOF 中记录的命令要一个个被重新执行，用于故障恢复，如果日志文件过大，整个恢复过程就会非常缓慢，这会影响到 Redis 的正常使用。

这个时候就要采取一定的控制手段，这个时候 AOF 重写机制登场了。

### 日志文件过大怎么办？

简单来说， AOF 重写机制就是在重写时， Redis 根据数据库的现状创建一个新的 AOF 文件，也就是说，读取数据库中所有的键值对，然后对每一个键值对用一条命令记录它的写入。

为什么重写机制可以把日志文件变小呢？实际上重写机制具有`多变一`功能。所谓的`多变一`，也就是，旧日志文件中的多条命令，在重写后的新日志中变成了一条命令。

我们知道， AOF 文件是以追加的方式，逐一记录接收到的写命令的，当一个键值对被多条写命令反复修改时， AOF 文件会记录相当多条命令，但是重写的时候，是根据这个键值对当前的最新状态，为它生成对应的写命令。这样一来，一个键值对在重写日志中只用一条命令就行了，而且，在日志恢复时，只用执行这条命令，就可以直接完成这个键值对的写入了。

![img](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202102/6528c699fdcf40b404af57040bb8d208.jpg)

我们先后对一个列表进行了 6 次修改操作，AOF重写之后，只需保证列表的最后状态，也就是一条命令`LPUSH u:list "N", "C", "D"`就能实现该数据的恢复，这样就节省了 5 条命令的空间，对于被修改成百上千次的键值对来说，重写能节省大量的空间。

虽然重写后，日志文件会缩小，但是要把整个数据库的最新数据的操作日志都写回磁盘，仍然是一个非常耗时的过程，这是，另一个问题是，重写会不会阻塞主线程？

### AOF 重写会阻塞吗？

和 AOF 日志由主线程写回不同，重写过程是由后台子进程`bgrewriteaof`来完成的，这也是为了避免阻塞主线程，导致数据库性能下降。

我把重写的过程总结为**一个拷贝，两处日志**

一个拷贝是指：每次执行重写时，主线程 fork 出后台的 `bgrewriteaof` 子进程.此时， fork 会把主线程的内存拷贝一份给子进程，这里面就包含了数据库的最新数据。然后子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。

两处日志：因为主线程未阻塞，仍然可以处理新的操作请求，此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志， Redis 会把这个操作写到它的缓冲区，这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。

而第二处日志，就是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时就可以用新的 AOF 文件代替旧的文件了。

![img](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202102/6b054eb1aed0734bd81ddab9a31d0be8.jpg)



总结来说：每次 AOF 重写时， Redis 会先执行一个内存拷贝，用于重写；然后使用两个日志保证在重写的过程中，新写入的数据不会丢失。而且由于Redis 采用额外的线程进行数据重写，所以，这个过程并不会阻塞主线程。